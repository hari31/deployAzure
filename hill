//In classical cryptography, the Hill cipher is a polygraphic substitution cipher based on linear algebra. Invented by Lester S. Hill in 1929, it was the first polygraphic cipher in which it was practical (though barely) to operate on more than three symbols at once
//Each letter is represented by a number modulo 26. Often the simple scheme A = 0, B = 1, ..., Z = 25 is used, but this is not an essential feature of the cipher. To encrypt a message, each block of n letters (considered as an n-component vector) is multiplied by an invertible n Ã— n matrix, against modulus 26. To decrypt the message, each block is multiplied by the inverse of the matrix used for encryption.
#include <stdio.h>
#include <math.h>
#include <malloc.h>
#include <string.h>
int N;
int mod (int a, int b) {
   int ret = a % b;
   if(ret < 0)
     ret+=b;
   return ret;
}
// Function to get cofactor of A[p][q] in temp[][]. n is current dimension of A[][]
void getCofactor(int **A, int **temp, int p, int q, int n) {
    int i = 0, j = 0, row, col;
    for (row = 0; row < n; row++)
        for (col = 0; col < n; col++)
            //  Copying into temporary matrix only those element which are not in given row and column
            if (row != p && col != q) {
                temp[i][j++] = A[row][col];
                // Row is filled, so increase row index and reset col index
                if (j == n - 1) {
                    j = 0;
                    i++;
                }
            }
}
 
/* Recursive function for finding determinant of matrix n is current dimension of A[][]. */
int determinant(int **A, int n) {
    int D = 0; // Initialize result
 
    //  Base case : if matrix contains single element
    if (n == 1)
        return A[0][0];
 
 	int i;
    int **temp = (int**)malloc(sizeof(int*) * N);
	for(i=0; i<N; i++) 
		temp[i] = (int*)malloc(sizeof(int) * N); // To store cofactors
 
    int sign = 1;  // To store sign multiplier
 
    // Iterate for each element of first row
    int f;
    for (f = 0; f < n; f++) {
        // Getting Cofactor of A[0][f]
        getCofactor(A, temp, 0, f, n);
        D += sign * A[0][f] * determinant(temp, n - 1);
 
        // terms are to be added with alternate sign
        sign = -sign;
    }
    return D;
}
void adjoint(int **A,int **adj) {
    if (N == 1) {
        adj[0][0] = 1;
        return;
    }
    int sign = 1, i, j;
    // temp is used to store cofactors of A[][]
    int **temp = (int**)malloc(sizeof(int*) * N);
	for(i=0; i<N; i++) 
		temp[i] = (int*)malloc(sizeof(int) * N);
 
    for (i=0; i<N; i++)
        for (j=0; j<N; j++) {
            // Get cofactor of A[i][j]
            getCofactor(A, temp, i, j, N);
 
            // sign of adj[j][i] positive if sum of row and column indexes is even.
            sign = ((i+j)%2==0)? 1: -1;
 
            // Interchanging rows and columns to get the transpose of the cofactor matrix
            adj[j][i] = sign * determinant(temp, N-1);
        }
}
void inverse(int **A, int **inverse) {
    int det = determinant(A, N);
    if (det == 0) {
        printf("Singular matrix, can't find its inverse");
        return;
    }
    det = mod(det, 26);
    printf("Determinant: %d\n", det);
    int d = 1;
    while(mod(det * d, 26) != 1)
        d++;
    printf("Inverse of Determinant: %d\n", d);
    
    int i, j;
    int **adj = (int**)malloc(sizeof(int*) * N);
	for(i=0; i<N; i++) 
		adj[i] = (int*)malloc(sizeof(int) * N);
    adjoint(A, adj);
    
    for (i=0; i<N; i++)
        for (j=0; j<N; j++)
            inverse[i][j] = mod(d * adj[i][j], 26);
 
    return;
}
int* enc_decrypt(int **k, int *r, int q) {
	int *c =(int*)malloc(sizeof(int)*257);
	int j1 = 0, j2 = 0, i, j;
	for(i=0; i<=q; i+=N)
		for(j1=0; j1<N; j1++) {
			int temp = 0, t = 0;
			for(j=i; j<i+N && j<q; j++) 
				temp += r[j] * k[j1][t++];
			if(temp == 0)
				break;
			c[j2++] = mod(temp, 26);
		}
	return c;
}
int main(int argc, char const *argv[]) {
    char *s = (char*)malloc(257);
	char *p = (char*)malloc(257);
	int *r = (int*)malloc(sizeof(int) * 257);
    
    printf("Enter the Key value of value n x n: ");
    scanf("%[^\n]s", s);
    N = (int)sqrt(strlen(s));
    int q=0, i=0, j=0;
    int **A = (int**)malloc(sizeof(int*) * N);
    int **inv =  (int**)malloc(sizeof(int*) * N);
    for(i=0; i<N; i++) {
        A[i] = (int*)malloc(sizeof(int) * N);
        inv[i] = (int*)malloc(sizeof(int) * N);
        for(j=0; j<N; j++)
            A[i][j] = s[q++] - 'A';
    }

    printf("Key matrix:\n");
    for(i=0; i<N; i++) {
        for(j=0; j<N; j++)
            printf("%2d ", A[i][j]);
        printf("\n");
    }
    getchar();
    printf("Enter the Plain Text: ");
    gets(p);
	for(i=0, j=0; j < strlen(p);) {
		for(j=i; j<strlen(p) && j<i+N; j++)
			r[q++] = p[j] - 'A';
		if(j != i+N) {
			while(j < i+N) {
				r[q++] = 'X' - 'A';
				j++;
			}
			break;
		}
		i = j;
	}
	
	int *c = enc_decrypt(A, r, q);
	printf("Encrypted text: ");
	for(i=0; i<q; i++)
		printf("%c", 'A'+c[i]);
	printf("\n");
	
	
	inverse(A, inv);
	
	
	printf("Inverse key matrix:\n");
	for(i=0; i<N; i++) {
		for(j=0; j<N; j++)
			printf("%2d ", inv[i][j]);
		printf("\n");
	}
		
	int *ans = enc_decrypt(inv, c, q);
	printf("Decrypted text: ");
	for(i=0; i<q; i++)
		printf("%c", 'A'+ans[i]);
	return 0;
}
